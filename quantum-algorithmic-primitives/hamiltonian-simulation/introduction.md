# Hamiltonian simulation

The task of Hamiltonian simulation is to approximately compile the evolution under a Hamiltonian $H(t)$, for time $t$, into a sequence of quantum gates. For a time-independent Hamiltonian, solving the Schrödinger equation yields a time evolution operator $U(t)=e^{-iHt}$. In this section we will discuss the equivalent operator $U(t) = e^{iHt}$, which is the more common definition in an algorithmic setting. The Hamiltonian of interest can arise from physical systems (e.g., [quantum chemistry](../../areas-of-application/quantum-chemistry/introduction.md#quantum-chemistry), [condensed matter systems](../../areas-of-application/condensed-matter-physics/introduction.md#condensed-matter-physics), or [quantum field theories](../../areas-of-application/nuclear-and-particle-physics/quantum-field-theories.md#quantum-field-theories)) but may also be constructed for other applications, such as [differential equation simulation](../../areas-of-application/solving-differential-equations.md#solving-differential-equations). Quantum simulation does not give full access to the amplitudes of the wavefunction during the simulation, unlike classical approaches based on exact diagonalization (or similar methods). Instead, we are only able to measure observables with respect to the time-evolved state, or use the state as an input to other quantum subroutines. Nevertheless, there are no known efficient classical methods that achieve this for general local or sparse Hamiltonians, suggesting an exponential quantum speedup. In fact, as a quantum computation can be expressed as a time evolution under a sequence of local (time-dependent) Hamiltonians, quantum simulation (i.e. time evolution and measurement of a given observable) is a BQP-complete problem.


Hamiltonian simulation algorithms require access to the Hamiltonian. There are three commonly used input models. The Pauli input model assumes that the Hamiltonian is given classically as a sum of products of Pauli operators, e.g. $H = \sum_l h_l H_l$, where $h_l$ are coefficients and $H_l$ are multiqubit Pauli products. The $d$-sparse access model assumes that the Hamiltonian is a sparse matrix with at most $d$ nonzero elements per row or column. We require that the locations of the nonzero elements and their values are efficient to compute classically. The density matrix access model assumes that the Hamiltonian corresponds to a density matrix, which we are either provided access to copies of [@lloyd2013QPrincipalCompAnal] or given a unitary that prepares a purification of the density matrix [@low2016HamSimQubitization]. All of these input models can be used to prepare [block-encodings](../../quantum-algorithmic-primitives/quantum-linear-algebra/block-encodings.md#block-encodings) of the Hamiltonian, which provides a standard form access model favored by some algorithms for Hamiltonian simulation (e.g. [qubitization with quantum signal processing](../../quantum-algorithmic-primitives/quantum-linear-algebra/quantum-signal-processing.md#quantum-signal-processingqubitization)) [@low2016HamSimQubitization].


Hamiltonian simulation can be used as a subroutine in a range of algorithms including: [quantum phase estimation](../../quantum-algorithmic-primitives/quantum-phase-estimation.md#quantum-phase-estimation), [quantum linear system solvers](../../quantum-algorithmic-primitives/quantum-linear-system-solvers.md#quantum-linear-system-solvers), [Gibbs state preparation](../../quantum-algorithmic-primitives/gibbs-sampling.md#gibbs-sampling), and the [quantum adiabatic algorithm](../../quantum-algorithmic-primitives/quantum-adiabatic-algorithm.md#quantum-adiabatic-algorithm). We remark that some of these algorithms are implicitly using Hamiltonian simulation to provide coherent, unitary access to the Hamiltonian. This can be particularly useful if few ancilla qubits are available, which may inhibit the use of some approaches to coherently access the Hamiltonian (e.g. [block-encodings based on linear-combinations of unitaries](../../quantum-algorithmic-primitives/quantum-linear-algebra/manipulating-block-encodings.md#linear-combinations)) but does not prevent the use of Hamiltonian simulation based on [product formulae](../../quantum-algorithmic-primitives/hamiltonian-simulation/product-formulae.md#product-formulae).


Each algorithm has its own advantages and disadvantages, as described at a high level in Table [0.7](#tab:HamiltonianSimulation){reference-type="ref" reference="tab:HamiltonianSimulation"}. Specific optimizations of each algorithm may be available for a given Hamiltonian. One can also consider hybridized methods combining two or more of the algorithms [@low2018HamiltonianInteractionPicture; @low2019Multiproduct; @Ouyang2020compilation; @hagan2022CompositeSimulation; @Rajput2022HybridizedMF; @watkins2022TimeDependentClockSimulation]. There are also other methods for Hamiltonian simulation, such as quantum walks [@childs2008OnRelContDiscQuantWalk; @berry2012BlackHamSimUnitImp; @berry2015HamSimNearlyOpt] or density matrix–based Hamiltonian simulation [@lloyd2013QPrincipalCompAnal; @kimmel2016hamiltonian], which we do not discuss, due to their less widespread use as algorithmic primitives for the applications discussed elsewhere in this document.


<figure markdown> <span id="tab:HamiltonianSimulation"></span>


|                                       |                                                                                                         |                         **qDRIFT**                          |                          **Taylor and Dyson series**                          |              **QSP/QSVT**               |
| :-—–—--—–—--—–—--—-: | :-—–—--—–—--—–—--—–—--—–—--—–—--—–—--—–—--—–—--—–—--: | :-—–—--—–—--—–—--—–—--—–—--—–-: | :-—–—--—–—--—–—--—–—--—–—--—–—--—–—--—-: | :-—–—--—–—--—–—--—–-: |
|             **\# Qubits**             |                                      $\mathcal{O}\left( n \right)$                                      |                $\mathcal{O}\left( n \right)$                |     $\mathcal{O}\left( n + \log(\nrm{H}_1 t\epsilon^{-1})\log(L) \right)$     | $\mathcal{O}\left( n + \log(L) \right)$ |
|                                       |                                                                                                         |                                                             |                                                                               |                                         |
|                 model                 |                                                                                                         |                                                             |                                                                               |                                         |
|                Sparse                 |                                                                                                         |                                                             |                                                                               |                                         |
|                Sparse                 |                                                                                                         |                                                             |                                                                               |                                         |
|                Sparse                 |                                                                                                         |                                                             |                                                                               |                                         |
|        Purified density matrix        |                                                                                                         |                                                             |                                                                               |                                         |
|              **Scaling**              | $\mathcal{O}\left( 5^{2k}nL \nrm{H}_1 t \left(\nrm{H}_1 t \epsilon^{-1} \right)^{\frac{1}{2k}} \right)$ | $\mathcal{O}\left(  n\nrm{H}_1^2 t^2\epsilon^{-1}  \right)$ | $\widetilde{\mathcal{O}}\left(  \nrm{H}_1 t n L \log(\epsilon^{-1})  \right)$ |                                         |
|               **Pros**                |                                                                                                         |                                                             |                                                                               |                                         |
|        Simple implementation.         |                                                                                                         |                                                             |                                                                               |                                         |
|        Empirical performance.         |                                                                                                         |                                                             |                                                                               |                                         |
|        Minimal ancilla qubits.        |                                                                                                         |                                                             |                                                                               |                                         |
|          No ancilla qubits.           |                                                                                                         |                                                             |                                                                               |                                         |
|      Time-dependent simulations.      |                                                                                                         |                                                             |                                                                               |                                         |
|   Few ancilla qubits for algorithm.   |                                                                                                         |                                                             |                                                                               |                                         |
|               **Cons**                |                                                                                                         |                                                             |                                                                               |                                         |
| Exponential prefactor (in order $k$). |                                       Scaling with $t, \epsilon$.                                       |                    Many ancilla qubits.                     |                                                                               |                                         |
| Ancilla/gate cost of block-encoding.  |                                                                                                         |                                                             |                                                                               |                                         |


<figcaption markdown>Table: High-level comparison of Hamiltonian simulation techniques. For the stated complexity, we consider evolution $U(t)=e^{iHt}$ for time $t$ under a time-independent Hamiltonian $H$ on $n$ qubits, given as a sum of $L$ Pauli products $H = \sum_{j=1}^L h_j P_j$. The evolution is approximate to error $\epsilon$ in the spectral norm (diamond norm for qDRIFT). We define $\smash{\nrm{H}_1 = \sum_{j=1}^L |h_j|}$. In specific applications it may be possible to reduce the number of qubits and/or gate complexity further by exploiting knowledge of the system, such as symmetries, commutation structure, or energy scales. For example, the factor of $n$ present in the above complexities may be reduced by exploiting locality in the Pauli product terms of the Hamiltonian. </figcaption> </figure>








