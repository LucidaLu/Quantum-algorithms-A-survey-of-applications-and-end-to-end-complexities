# Quantum linear algebra

At a high level of abstraction, quantum computers compose unitary matrices, and do so with classically unparalleled efficiency. This hints at quantum speedups for linear algebra tasks. However, often one needs to work with large non-unitary matrices; thus, for performing general linear algebra tasks we often wish to embed certain non-unitary matrices into unitary matrices represented by efficient quantum circuits, and then apply them to quantum states, take their sums or products, or implement more general matrix functions. These tasks are collectively referred to as "quantum linear algebra," the building blocks of which are discussed in this section.


The techniques described in this section evolved over the past decades and converged to the presented unified framework within several distinct research threads. [Block-encodings](../../quantum-algorithmic-primitives/quantum-linear-algebra/block-encodings.md#block-encodings) emerged as a natural approach for embedding non-unitary matrices into quantum circuits, inspired by approaches based on purification, dilation,[^1] and postselection. [Quantum signal processing](../../quantum-algorithmic-primitives/quantum-linear-algebra/quantum-signal-processing.md#quantum-signal-processing) (QSP) was discovered as a byproduct of the characterization of simple single-qubit pulse sequences used in nuclear magnetic resonance [@low2016CompositeQuantGates], for synthesizing polynomial transformations applicable to a "signal parameter" encoded as a matrix element of a single-qubit rotation matrix. Meanwhile, it was extensively studied how matrix functions could be synthesized using the [linear combinations of unitaries](../../quantum-algorithmic-primitives/quantum-linear-algebra/manipulating-block-encodings.md#linear-combinations) technique on matrix exponentials implemented by Hamiltonian simulation [@childs2012HamSimLCU; @apeldoorn2017QSDPSolvers; @chakraborty2018BlockMatrixPowers], or Chebyshev polynomials of operators implemented via quantum walk techniques [@berry2013ExpPrecHamSimSTOC; @berry2015HamSimNearlyOpt; @childs2015QLinSysExpPrec]. Such matrix exponentials or Chebyshev polynomials can be implemented, e.g., via [qubitization](../../quantum-algorithmic-primitives/quantum-linear-algebra/qubitization.md#qubitization) of a block-encoded operator. In parallel to progress on advanced [amplitude amplification](../../quantum-algorithmic-primitives/amplitude-amplification-and-estimation/amplitude-amplification.md#amplitude-amplification) [@grover2005FixedPointSearch; @yoder2014FixedPointSearch] techniques, it was recognized [@low2016HamSimQSignProc; @low2016HamSimQubitization] that QSP can be "lifted" for applying polynomial transformations to the eigenvalues of quantum walk operators (such as those implemented by qubitization), and thus for implementing a rich family of matrix functions, immediately yielding an optimal algorithm for time-independent [Hamiltonian simulation](../../quantum-algorithmic-primitives/quantum-linear-algebra/quantum-signal-processing.md#quantum-signal-processingqubitization). The concepts of qubitization and QSP were later generalized and unified into the framework of [quantum singular value transformation](../../quantum-algorithmic-primitives/quantum-linear-algebra/quantum-singular-value-transformation.md#quantum-singular-value-transformation) [@gilyen2018QSingValTransf], providing generalizations and more efficient implementations of a number of existing quantum algorithms and leading to the discovery of several new algorithms. 






[^1]: That is, representing an incoherent state or operation as a coherent one with the help of an ancillary systemâ€”see for example Stinespring representation [@wolf2012QChannelsOpsLectureNotes] or Stinespring dilation [@wilde2017QIT].

